// DO NOT MODIFY DIRECTLY
// This file was generated by the tools.blade.GenerateAst
package org.blade.language.parser.ast;

import org.blade.language.parser.Token;

import java.util.List;

public abstract class Expr extends AST {
  public abstract<T> T accept(Visitor<T> visitor);

  public interface Visitor<T> {
    T visitNilExpr(Nil expr);
    T visitBooleanExpr(Boolean expr);
    T visitNumberExpr(Number expr);
    T visitBigNumberExpr(BigNumber expr);
    T visitLiteralExpr(Literal expr);
    T visitUnaryExpr(Unary expr);
    T visitBinaryExpr(Binary expr);
    T visitLogicalExpr(Logical expr);
    T visitRangeExpr(Range expr);
    T visitGroupingExpr(Grouping expr);
    T visitIdentifierExpr(Identifier expr);
    T visitConditionExpr(Condition expr);
    T visitCallExpr(Call expr);
    T visitGetExpr(Get expr);
    T visitSetExpr(Set expr);
    T visitIndexExpr(Index expr);
    T visitSliceExpr(Slice expr);
    T visitArrayExpr(Array expr);
    T visitDictExpr(Dict expr);
    T visitNewExpr(New expr);
    T visitParentExpr(Parent expr);
    T visitSelfExpr(Self expr);
    T visitAssignExpr(Assign expr);
    T visitAnonymousExpr(Anonymous expr);
    T visitExpr(Expr expr);
  }

  public static class Nil extends Expr {
    public Nil() {
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitNilExpr(this);
    }
  }

  public static class Boolean extends Expr {
    public final boolean value;

    public Boolean(boolean value) {
      this.value = value;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitBooleanExpr(this);
    }
  }

  public static class Number extends Expr {
    public final Token token;

    public Number(Token token) {
      this.token = token;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitNumberExpr(this);
    }
  }

  public static class BigNumber extends Expr {
    public final Token token;

    public BigNumber(Token token) {
      this.token = token;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitBigNumberExpr(this);
    }
  }

  public static class Literal extends Expr {
    public final Token token;

    public Literal(Token token) {
      this.token = token;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitLiteralExpr(this);
    }
  }

  public static class Unary extends Expr {
    public final Token op;
    public final Expr right;

    public Unary(Token op, Expr right) {
      this.op = op;
      this.right = right;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitUnaryExpr(this);
    }
  }

  public static class Binary extends Expr {
    public final Expr left;
    public final Token op;
    public final Expr right;

    public Binary(Expr left, Token op, Expr right) {
      this.left = left;
      this.op = op;
      this.right = right;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitBinaryExpr(this);
    }
  }

  public static class Logical extends Expr {
    public final Expr left;
    public final Token op;
    public final Expr right;

    public Logical(Expr left, Token op, Expr right) {
      this.left = left;
      this.op = op;
      this.right = right;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitLogicalExpr(this);
    }
  }

  public static class Range extends Expr {
    public final Expr lower;
    public final Expr upper;

    public Range(Expr lower, Expr upper) {
      this.lower = lower;
      this.upper = upper;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitRangeExpr(this);
    }
  }

  public static class Grouping extends Expr {
    public final Expr expression;

    public Grouping(Expr expression) {
      this.expression = expression;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitGroupingExpr(this);
    }
  }

  public static class Identifier extends Expr {
    public final Token token;

    public Identifier(Token token) {
      this.token = token;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitIdentifierExpr(this);
    }
  }

  public static class Condition extends Expr {
    public final Expr expression;
    public final Expr truth;
    public final Expr falsy;

    public Condition(Expr expression, Expr truth, Expr falsy) {
      this.expression = expression;
      this.truth = truth;
      this.falsy = falsy;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitConditionExpr(this);
    }
  }

  public static class Call extends Expr {
    public final Expr callee;
    public final List<Expr> args;

    public Call(Expr callee, List<Expr> args) {
      this.callee = callee;
      this.args = args;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitCallExpr(this);
    }
  }

  public static class Get extends Expr {
    public final Expr expression;
    public final Identifier name;

    public Get(Expr expression, Identifier name) {
      this.expression = expression;
      this.name = name;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitGetExpr(this);
    }
  }

  public static class Set extends Expr {
    public final Expr expression;
    public final Identifier name;
    public final Expr value;

    public Set(Expr expression, Identifier name, Expr value) {
      this.expression = expression;
      this.name = name;
      this.value = value;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitSetExpr(this);
    }
  }

  public static class Index extends Expr {
    public final Expr callee;
    public final Expr argument;

    public Index(Expr callee, Expr argument) {
      this.callee = callee;
      this.argument = argument;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitIndexExpr(this);
    }
  }

  public static class Slice extends Expr {
    public final Expr callee;
    public final Expr lower;
    public final Expr upper;

    public Slice(Expr callee, Expr lower, Expr upper) {
      this.callee = callee;
      this.lower = lower;
      this.upper = upper;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitSliceExpr(this);
    }
  }

  public static class Array extends Expr {
    public final List<Expr> items;

    public Array(List<Expr> items) {
      this.items = items;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitArrayExpr(this);
    }
  }

  public static class Dict extends Expr {
    public final List<Expr> keys;
    public final List<Expr> values;

    public Dict(List<Expr> keys, List<Expr> values) {
      this.keys = keys;
      this.values = values;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitDictExpr(this);
    }
  }

  public static class New extends Expr {
    public final Expr expression;
    public final List<Expr> arguments;

    public New(Expr expression, List<Expr> arguments) {
      this.expression = expression;
      this.arguments = arguments;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitNewExpr(this);
    }
  }

  public static class Parent extends Expr {
    public Parent() {
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitParentExpr(this);
    }
  }

  public static class Self extends Expr {
    public Self() {
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitSelfExpr(this);
    }
  }

  public static class Assign extends Expr {
    public final Expr expression;
    public final Expr value;

    public Assign(Expr expression, Expr value) {
      this.expression = expression;
      this.value = value;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitAssignExpr(this);
    }
  }

  public static class Anonymous extends Expr {
    public final Stmt.Function function;

    public Anonymous(Stmt.Function function) {
      this.function = function;
    }

    public <T> T accept(Visitor<T> visitor) {
      return visitor.visitAnonymousExpr(this);
    }
  }
}
